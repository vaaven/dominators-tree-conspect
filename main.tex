\documentclass[a4paper, fontsize=12pt]{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[russian]{babel}
\usepackage{scrextend} 
\usepackage{amsmath}
\usepackage{listings}
% \usepackage{concrete}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Дерево доминаторов}
\author{Лазарев Никита}

\begin{document}
\maketitle

\newtheorem{theorem}{Лемма} % чтобы заработало окружение теорем

\section{Введение}

\subsection{Определение}

Давайте рассмотрим ориентированный граф $(V, E)$. Пусть в этом графе отмечена какая-то вершина $S$, назовем ее истоком. 

Вершина $u$ считается доминатором вершины $v$, если все пути из $S$ в $v$ проходят через $u$. Определим непосредственным доминатором вершины $v$, такую вершину $u$, что количество вершин, для которых $u$ является доминатором минимально. Для удобства давайте дальше будем называть непосредственный доминатор для вершины $v$, как $idom_v$ (immediate dominator - непосредственный доминатор).

Предположим, что мы знаем все $idom_v$. Давайте построим граф, в котором вершины будут идентичны изначально графу, а ребра будут вида $idom_v \rightarrow v$. Именно такой граф и называется деревом доминаторов.

 
\begin{theorem} \label{t1}
Давайте докажем, что дерево доминаторов является деревом.

Предположим, что это не так, тогда у нас есть три вершины $a, b, c$, такие что мы имеем пути $a \rightarrow b$, $b \rightarrow c$, $a \rightarrow c$, которые не пересекаются по вершинам, кроме вершин $a, b, c$, при чем путь от $b$ до $c$ состоит из одного ребра. Но тогда у нас есть два пути до вершины $c$, один из которых не проходит через $b$, а значит $b$ не является доминатором $c$. Получили противоречие.
\end{theorem}

\subsection{Построение дерева доминаторов за $O(nm)$}

Сначала очевидно обработаем все вершины до которых мы не можем добраться из $S$. Далее будем удалять каждую по одной вершине и запускать DFS из $S$. Тогда мы получим для каждой вершины список вершин для которых она является доминатором. Построить дерево доминаторов по этому списку достаточно легко. Давайте сделаем на полученном списке граф, очевидно что он получится DAG'ом. Теперь для каждой вершины нам нужно найти самый длинный путь до этой вершины из $S$. Именно такой путь и должен быть в нашем дереве доминаторов. Все эти этапы можно делать за $O(nm)$ 

\newpage

\section{Полудоминаторы}

\subsection{Определение}

Для построения дерева доминаторов за $O((n + m) log n)$ нам понадобится такая вещь как полудоминаторы. 

Перед тем как определять полудоминаторы. Давайте перенумеруем вершины в порядке входа в дерево обхода DFS. 

Определим полудоминатор вершины $v$ как такую минимальную вершину $sdom_v$, что существует путь через вершины $sdom_v, v_1, v_2, v_3, \ldots, v$, такой что $v_i > v$ (здесь номер вершины это уже измененная версия, то есть $tin_v$).

\begin{theorem} \label{t2}
Давайте дакажем, что если $v \neq S$, то $sdom_v$ предок вершины $v$ в дереве DFS. 

Заметим, что самый первый претендент на то чтобы быть полудоминатором это непосредственный предок $v$. Тогда $sdom_v \leq parent_v$. Если $sdom_v$ не является предком $v$, то тогда $sdom_v$ лежит в каком-то левом поддереве относительно $v$. Но тогда у нас есть путь из левого поддерева в $v$. А это значит что мы должны были посетить вершину $v$ в этом поддереве и наше дерево обхода DFS неверное.

\end{theorem}

\begin{theorem} \label{t3}
Давайте дакажем, что если $v \neq S$, то $idom_v$ предок вершины $sdom_v$ в дереве DFS.

Во-первых, очевидно, что $idom_v$ является предком $v$(поймите сами почему так).

Во-вторых, предположим, что $idom_v$ лежит ниже чем $sdom_v$, но тогда мы имееем два различных путя из $S$ в $v$(банально по определению полудоминатора). Имеем противоречение. 

\end{theorem}

\subsection{Поиск полудоминаторов}

Посмотрим на наш $sdom_v$. Каждому полудоминатору, как мы сказали ранее, соответствует путь $sdom_v, v_1, v_2, v_3, \ldots, v$, при чем $v_i > v$. Давайте посмотрим на предпоследнюю вершину, то есть $v_m$. По условию у нас есть ребро $v_m \rightarrow v$. Будем пересчитывать полудомнатор именно через такие вершины $v_m$. 

Посмотрим на какую-то вершину $v$, мы можем дойти до нее от полудоминатора через вершины $B$, такие что $B \rightarrow v$. Если $B < v$, то $B$ - претендент на полудоминатор, но не более, потому что мы не можем проходить через эту вершину на пути в $v$.

Для остальных $B > v$ мы хотим пересчитать $sdom_v$ как-то поумнее. 

\begin{theorem} \label{t4}
Возьмем две наши вершины $v$ и $B$. Они лежат в разных поддеревьях дерева обхода DFS. Давайте посчитаем их lca в этом дереве, пусть это будет вершина $S$. Утверждается, что $sdom_v = min sdom_u$, для всех таких u, которые лежат на пути от $S$ до $B$, кроме конечно вершины $S$.

Докажем это. Пусть мы уже знаем полудоминатор $C$ нашей вершины $v$. Если у нас есть ребро $C \rightarrow v$, то мы победили. Иначе рассмотрим путь из $С$ в $v$(этот путь будет вида $C, v_1, v_2, v_3, \ldots, B, v$). 

Давайте рассмотрим минимальную вершину $D$ среди вершин \\ $v_1, v_2, v_3, \ldots, B$. Легко осознать, что $C$ подходит под определение полудоминатора для $D$, поэтому $sdom_D \leq C$. Однако заметим, что полудоминатор $sdom_D$ является полудоминатором $A$. Это происходит из-за того что все вершины на пути из $sdom_D$ в $D$ больше чем $v$, а также у нас есть путь из $D$ в $v$ по вершинам больше $v$. Из этих рассуждений можно сделать вывод, что $C = sdom_D$.

Из этого рассуждения мы можем понять, что либо у нас полудоминатор вершины это какой-то ее сосед, либо мы ее будем пересчитывать через вершины с бОльшим номером чем $v$.

Следующее существенное замечаение состоит в том, что $D$ лежит на пути из $C$ в $B$. Давайте докажем это. Так как $D < B$ и $B$ достижима из $D$, то $D$ лежит выше в дереве дфса $B$.
\end{theorem}


\subsection{Построение полудоминаторов за $O(nm)$} 

Давайте будем рассматривать вершины в порядке уменьшения номера.

Пусть сейчас мы рассматриваем вершину $v$. Посмотрим на все вершины $B$, такие что есть ребро $B \rightarrow v$. Если $B < v$, то $B$ кандидат на $sdom_v$. Иначе давайте будем подниматься из $B$ выше в дереве DFS'a пока не наткнемся на вершину с номером меньше $v$. Если мы прошли через вершины $D_1, D_2, D_3, D_4 \ldots, D_k$, то у нас есть $sdom_{D_1}, sdom_{D_2}, \ldots, sdom_{D_k}$ - претенденты на $sdom_v$. Мы можем просто банально пройтись по всем этим вершинам и прорелаксировать $sdom_v$. Заметим что для каждого ребра мы будем подниматься в дереве DFS'а не более $n$ раз, поэтому ассимптотика этого решения будет $O(nm)$.

\subsection{Построение полудоминаторов за $O((n + m) log n)$}

В решении за $O(nm)$ у нас дольше всего времени занимало поднятие по вершинам до LCA. Это можно оптимизировать либо с помощью HLD, либо можно сделать умнее и написать структуру под название link-eval. 

Она поддерживает следующие операции:

\begin{itemize}
    \item link(a, b) - подвесить b за a. 
    \item eval(a) - посчитать какую-то функцию на пути от $а$ до корня поддерева в котором находится $a$.
\end{itemize}

Тогда алгоритм описанный выше можно реализовать за $O((n + m) log n)$.

\newpage

\section{Поиск доминаторов}

\subsection{Важные факты}

Перед тем как рассказать про алгоритм давайте опишем еще пару важных свойств. 

\begin{theorem} \label{t5}
Пусть существует вершина $v$, и мы знаем ее $idom_v$. Тогда если есть какая то вершина $u$, такая что она предок $v$, а $idom_v$ предок $v$, то $idom_v$ является предком $idom_u$. 

Преположим, что это не так. Тогда есть два путя из $idom_u$ в $u$. И так как $u$ это предок $v$, поэтому есть два пути из $idom_u$ в $v$. Из-за этого есть путь из $idom_u$ в $v$, который не проходит через $idom_v$. Получили противоречие.
\end{theorem}

\begin{theorem} \label{t6}
Предположим есть вершина $v$ и мы знаем ее $sdom_v$. Утверждается, что если для всех вершин $u$, таких что $u$ предок $v$, а $sdom_v$ предок $u$, верно что $sdom_v \leq sdom_u$, то $idom_v = sdom_v$. 

Давайте банально предположим обратное. Тогда у нас есть путь из $idom_v$ в $v$ в обход $sdom_v$. Как может идти этот путь? Рассмотрим два варианта.

Первый вариант это когда у нас есть ребро на пути $idom_v \rightarrow sdom_v$, который ведет либо в поддерево вершины $v$ и потом поднимается в $v$, либо идет в правое поддерево и потом ведет каким-то ребром в $v$. Но в таком случае $sdom_v$ должен быть выше(а именно той вершиной из которой ведет это ребро). Получили противоречие.

Второй вариант. Это когда у нас есть ребро которое выходит из вершины на пути $idom_v \rightarrow sdom_v$ и входит в вершину на пути $sdom_v \rightarrow v$, но тогда у нас $sdom_v \leq sdom_u$, что неверно по условию.    
\end{theorem}

\begin{theorem} \label{t7}
Предположим есть вершина $v$ и мы знаем ее $sdom_v$. Утверждается, что если для всех вершин $u$, таких что $u$ предок $v$, а $sdom_v$ предок $u$, верно что $sdom_u \leq sdom_v$, то $idom_v = idom_u$.

По теореме \ref{t5} имеем что $idom_u \leq idom_v$. Предположим, что $idom_u < idom_v$. Тогда должен быть путь $idom_u \rightarrow u$ в обход $idom_v$. Рассмотрим два варианта схожих теореме \ref{t6}.

В первом варианте у нас путь не содержит ребра на пути $sdom_u \rightarrow u$. Рассуждения в этом варианте аналогичны первому варианту из \ref{t6}.

Второй вариант интереснее. Давайте посмотрим на наш путь в обход $idom_v$. Возьмем первую вершину на этом пути для которой выполняется условие что она предок $v$, а также что $idom_u$ - ее предок. Пусть эта вершина будет с номером $y$. Заметьте, что мы не накладываем никаких условий положения относительно $u$ ($y$ можем быть как ниже так и выше $u$).

Если у нас $u < y$ (то есть $y$ выше $u$ в дереве обхода DFS), то у нас есть путь из $idom_v$ в $u$ в обход $idom_u$. Получили противоречие.

Если $u > y$ (то есть $y$ ниже $u$), то $sdom_y < sdom_u$. Это противоречит тому, что $sdom_u \rightarrow min$. Получили противоречие.

Тогда $idom_v = idom_u$. Ч.т.д. 
\end{theorem}


\begin{theorem} \label{t8}
Предположим есть вершина $v$ и мы знаем ее $sdom_v$. 
Найдем вершину $u$ с минимальным $sdom_u$, такую что $sdom_v$ - предок $u$, а $u$ - предок $v$. Тогда утверждается, что:

\begin{equation*}
idom_v = 
 \begin{cases}
   sdom_v &\text{если $sdom_v = sdom_u$}\\
   idom_u &\text{в противном случае}
 \end{cases}
\end{equation*}

Это утверждение легко выводится из теорем \ref{t6} и \ref{t7}.

\end{theorem}

\subsection{Нахождение $idom$ за $O((n + m) log n)$}

Перед тем как строить доминаторы, давайте построим полудоминаторы за $O((n + m)logn)$.

Теперь из утверждения в теореме \ref{t8} легко понять как искать доминаторы. Во-первых $idom$ надо считать в порядке обхода DFS. Во вторых нам надо уметь находить минимум на пути. Это легко сделать просто поддерживая двоичные подъемы и минимум на них. 

Мы смогли построить дерево доминатров за $O((n+ m)logn)$.

\newpage

\section{Реализация}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstinputlisting[
    caption=структура link-eval,
    label={lst:listing-cpp},
    language=C++,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    keepspaces=true,                 
    numbers=left,       
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    ]{linkeval.cpp}

\newpage

\lstinputlisting[
    caption=построение полудоминаторов,
    label={lst:listing-cpp},
    language=C++,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    keepspaces=true,                 
    numbers=left,       
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    ]{buildsdom.cpp}

\lstinputlisting[
    caption=построение дерева доминаторов,
    label={lst:listing-cpp},
    language=C++,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    keepspaces=true,                 
    numbers=left,       
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    ]{buildidom.cpp}

\end{document}